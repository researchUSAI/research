<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>nexus</title>
  <style>
    body {
      background: #181818;
      color: #BDCEF1;
      font-family: 'Courier New', monospace;
      height: 100vh;
      width: 100vw;
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      font-size: 16px;
      line-height: 24px;
      overflow-y: auto;
      overflow-x: hidden;
    }
    #display {
      flex: 1 1 auto;
      white-space: pre-wrap;
      word-break: break-all;
      overflow-wrap: anywhere;
      max-width: 78ch;
      padding: 0 1ch;
      line-height: 1;
    }
    #input {
      flex: 0 0 auto;
      display: block;
      border: none;
      outline: none;
      background: transparent;
      color: inherit;
      font-family: inherit;
      font-size: inherit;
      min-height: 3em;
      padding: 0 1ch;
    }
    #input .input-reverse {
      background: #BDCEF1;
      color: #181818;
    }
    #controls {
      flex: 0 0 auto;
      padding: 1ch;
      display: flex;
      gap: 1ch;
      background: #111;
      border-top: 1px solid #333;
      justify-content: center;
    }
    button {
      background: #333;
      color: #BDCEF1;
      border: 1px solid #555;
      padding: 0.5ch 1ch;
      font-family: inherit;
      cursor: pointer;
      min-width: 90px;
    }
    button:hover {
      background: #444;
    }
    button.polarity-truth {
      background: #006600;
    }
    button.polarity-exploration {
      background: #660000;
    }
    .config-line {
      margin-bottom: 0.5em;
    }
    .config-label {
      color: #888;
    }
    .config-value {
      color: #BDCEF1;
      background: #222;
      padding: 0 0.5ch;
      cursor: text;
      display: inline-block;
      min-width: 20ch;
    }
    .reverse-video {
      background: #BDCEF1;
      color: #181818;
    }
    #measure {
      position: absolute;
      visibility: hidden;
      font-family: 'Courier New', monospace;
      white-space: pre;
    }
  </style>
</head>
<body>
  <div id="display"></div>
  <div id="input" contenteditable="true"></div>

  <div id="controls">
    <button id="export-btn">Export</button>
    <button id="back-btn">Back</button>
    <button id="polarity-btn">Polarity: <span id="polarity-text">Truth</span></button>
  </div>

  <span id="measure">M</span>

  <script>
    const State = {
      PROBE_WAIT: 'probe_wait',
      PROBE_RECOVER_RESPONSE: 'probe_recover_response',
    };

    class Structure {
      constructor() {
        this.id = `s_${Date.now()}`;
        this.date = new Date().toLocaleDateString();
        this.day = new Date().toLocaleDateString('en-US', { weekday: 'short' });
        this.releaseTime = null;
        this.log = [];
      }
      addInitiation(probe) {
        this.log.push({ type: 'initiation', id: `i_${Date.now()}`, timestamp: Date.now(), probe });
      }
      addResponse(probe) {
        this.log.push({ type: 'response', id: `r_${Date.now()}`, timestamp: Date.now(), probe });
      }
      release() {
        this.releaseTime = new Date().toLocaleTimeString();
        const blob = new Blob([JSON.stringify(this, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${this.id}.json`;
        a.click();
        URL.revokeObjectURL(url);
      }
    }

    class Nexus {
      constructor() {
        this.state = State.PROBE_RECOVER_RESPONSE;
        this.structures = [];
        this.currentStructure = new Structure();
        this.stack = [];
        this.localBackend = 'https://researchnexus.onrender.com';
        this.modelEndpoint = 'https://api.groq.com/openai/v1';
        this.model = 'llama-3.1-70b-versatile';
        this.apiKey = '';
        this.truth = true;
        this.dotCount = 0;
        this.dotInterval = null;
        this.display = document.getElementById('display');
        this.input = document.getElementById('input');
        this.measure = document.getElementById('measure');
        this.polarityText = document.getElementById('polarity-text');
        this.setupEvents();
        this.updateDimensions();
        this.updatePolarityDisplay();
      }

      setupEvents() {
        window.addEventListener('resize', () => this.updateDimensions());

        this.input.addEventListener('input', () => {
          this.normalizeInput();
        });

        document.addEventListener('keydown', async (e) => {
          if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            const probe = this.input.textContent.trim();
            if (probe) {
              this.input.innerHTML = '';
              await this.sendProbe(probe);
            }
          }
        });

        // Editable fields
        this.display.addEventListener('input', (e) => {
          if (e.target.classList.contains('config-value')) {
            const id = e.target.id;
            const value = e.target.textContent.trim();
            if (id === 'edit-endpoint') this.modelEndpoint = value;
            if (id === 'edit-model') this.model = value;
            if (id === 'edit-key') this.apiKey = value;
          }
        });

        // Buttons
        document.getElementById('export-btn').addEventListener('click', () => {
          if (this.currentStructure) this.currentStructure.release();
        });

        document.getElementById('back-btn').addEventListener('click', () => {
          if (this.stack.length > 0 && this.stack[this.stack.length - 1].startsWith('1:\n')) {
            this.stack.pop();
          }
          this.render();
        });

        document.getElementById('polarity-btn').addEventListener('click', () => {
          this.truth = !this.truth;
          this.updatePolarityDisplay();
          this.render();
        });
      }

      async sendProbe(probe) {
        this.stack.push(`0:\n${probe}`);
        this.currentStructure.addInitiation(probe);
        this.state = State.PROBE_WAIT;
        this.startWait();
        this.render();

        const response = await this.coordinate(probe);
        this.stopWait();
        this.stack.push(`1:\n${response}`);
        this.currentStructure.addResponse(response);
        this.state = State.PROBE_RECOVER_RESPONSE;
        this.render();
      }

      updatePolarityDisplay() {
        this.polarityText.textContent = this.truth ? 'Truth' : 'Exploration';
        document.getElementById('polarity-btn').className = this.truth ? 'polarity-truth' : 'polarity-exploration';
      }

      updateDimensions() {
        this.measure.style.fontSize = '100px';
        const measuredWidth = this.measure.offsetWidth;
        const pixelsPerChar = measuredWidth / 1;
        const targetWidth = window.innerWidth;
        const newFontSize = (targetWidth / 80) * (100 / pixelsPerChar);
        const newLineHeight = window.innerHeight / 24;
        document.body.style.fontSize = `${newFontSize}px`;
        document.body.style.lineHeight = `${newLineHeight}px`;
      }

      startWait() {
        this.dotCount = 0;
        if (this.dotInterval) clearInterval(this.dotInterval);
        this.dotInterval = setInterval(() => {
          this.dotCount = (this.dotCount + 1) % 4;
          this.render();
        }, 800); // slightly faster cycle
      }

      stopWait() {
        if (this.dotInterval) clearInterval(this.dotInterval);
        this.dotInterval = null;
        this.dotCount = 0;
      }

      async coordinate(probe) {
        let fullProbe = '';
        if (this.structures.length > 0) {
          for (const structure of this.structures) {
            for (const entry of structure.log) {
              fullProbe += entry.type === 'initiation' ? `0:\n${entry.probe}\n` : `1:\n${entry.probe}\n`;
            }
          }
        }
        if (this.stack.length > 0) fullProbe += this.stack.join('\n') + '\n';
        fullProbe += probe;

        try {
          const response = await fetch(`${this.localBackend}/generate_prompt`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              probe: fullProbe,
              truth: this.truth,
              base_url: this.modelEndpoint,
              api_key: this.apiKey,
              model: this.model
            })
          });

          if (!response.ok) throw new Error(await response.text());

          const reader = response.body.getReader();
          let fullResponse = '';
          while (true) {
            const { done, value } = await reader.read();
            if (done) break;
            fullResponse += new TextDecoder().decode(value);
            // Update last stack entry live for streaming effect
            if (this.stack.length > 0 && this.stack[this.stack.length - 1].startsWith('1:\n')) {
              this.stack[this.stack.length - 1] = `1:\n${fullResponse}`;
            } else {
              this.stack.push(`1:\n${fullResponse}`);
            }
            this.render();
          }
          return fullResponse;
        } catch (e) {
          return `[ERROR] ${e.message}`;
        }
      }

      render() {
        let output = `
          <div class="config-line"><span class="config-label">endpoint:</span> <span id="edit-endpoint" class="config-value" contenteditable="true">${this.modelEndpoint || 'NULL'}</span></div>
          <div class="config-line"><span class="config-label">model:</span> <span id="edit-model" class="config-value" contenteditable="true">${this.model || 'NULL'}</span></div>
          <div class="config-line"><span class="config-label">key:</span> <span id="edit-key" class="config-value" contenteditable="true">${this.apiKey ? '••••••••' : 'NULL'}</span></div>
        `;

        if (this.stack.length > 0) output += this.stack.join('\n') + '\n';

        if (this.state === State.PROBE_WAIT) {
          let dots = '';
          if (this.dotCount === 1) dots = '.';
          else if (this.dotCount === 2) dots = '..';
          else if (this.dotCount === 3) dots = '...';
          output += `Thinking${dots}`;
        }

        this.display.innerHTML = output;
        this.input.focus();
      }

      normalizeInput() {
        const selection = window.getSelection();
        let cursorOffset = 0;

        if (selection.rangeCount > 0) {
          const range = selection.getRangeAt(0);
          const preCaretRange = range.cloneRange();
          preCaretRange.selectNodeContents(this.input);
          preCaretRange.setEnd(range.endContainer, range.endOffset);
          cursorOffset = preCaretRange.toString().length;
        }

        const textContent = this.input.textContent;

        this.input.innerHTML = '';
        if (textContent) {
          const span = document.createElement('span');
          span.className = 'input-reverse';
          span.textContent = textContent;
          this.input.appendChild(span);

          try {
            const range = document.createRange();
            const textNode = span.firstChild;
            if (textNode) {
              const offset = Math.min(cursorOffset, textNode.length);
              range.setStart(textNode, offset);
              range.collapse(true);
              selection.removeAllRanges();
              selection.addRange(range);
            }
          } catch (e) {
            const range = document.createRange();
            range.selectNodeContents(this.input);
            range.collapse(false);
            selection.removeAllRanges();
            selection.addRange(range);
          }
        }
      }
    }

    const nexus = new Nexus();
    nexus.render();
  </script>
</body>
</html>
